解題想法：
假設地圖為 (0='#'  1='.')
0 0 0 A 1 1 1
1 1 1 1 1 0 0
0 1 1 0 1 1 0
0 B 1 1 1 1 1   ===========>等等會把 B 改成 1，下方為了標示清楚才加'*'，判斷過程不會加
1 0 0 0 0 0 0
0 0 0 0 0 0 0
1 0 0 0 1 0 0

第一次移動結果為
0 0 0 A 0 1 1
1 1 1 D 1 0 0
0 1 1 0 1 1 0
0*1 1 1 1 1 1
1 0 0 0 0 0 0
0 0 0 0 0 0 0
1 0 0 0 1 0 0

第二次
0 0 0 A 0 1 1
1 1 L D R 0 0
0 1 1 0 1 1 0
0*1 1 1 1 1 1
1 0 0 0 0 0 0
0 0 0 0 0 0 0
1 0 0 0 1 0 0

第三次
0 0 0 A 0 1 1
1 L L D R 0 0
0 1 D 0 D 1 0
0*1 1 1 1 1 1
1 0 0 0 0 0 0
0 0 0 0 0 0 0
1 0 0 0 1 0 0

四
0 0 0 A 0 1 1
L L L D R 0 0
0 D D 0 D R 0
0*1 D 1 D 1 1
1 0 0 0 0 0 0
0 0 0 0 0 0 0
1 0 0 0 1 0 0

五
0 0 0 A 0 1 1
L L L D R 0 0
0 D D 0 D R 0
0*L D L D D 1     ==========>B已經到達，變成L（從它右邊的D過來的）
1 0 0 0 0 0 0
0 0 0 0 0 0 0
1 0 0 0 1 0 0

要如何判斷什麼時候無解？要怎麼判斷下一步要走哪裡？
可以設一個 vector<pair<int,int>> 存放所有路徑的末座標，若末座標（正在判斷的那個位置）發現是死路，則這整條路徑就直接從vector內移除。例如：
  (1)第一步時，A產生了一條往下的路徑，末座標為(3,1)
  (2)第二步，(3,1)產生分枝。有兩條路徑  (3,1)-(2,1) 和  (3,1)-(4,1) ，先把原本的末座標(3,1)從vector內移除，再加入(2,1)和(4,1)
當vector內完全沒有元素就代表沒有任何路徑，則找不到路到B點，故無解。

要判斷回去的路就是：若該點為L，就判斷它右邊的；若為U，就判斷他下面的。反向推回去。儲存到 vector裡

==================================================================
reference:
https://www.youtube.com/watch?v=zsBpBtZkCOQ
https://openhome.cc/zh-tw/algorithm/basics/maze/
